<?php

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use App\Article;

class articlesTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        Article::create(['id'=>'1', 'title'=>'Такие разные заголовки! Изучаем HTTP-взаимодействие', 'text'=>'Большинство из нас многократно слышали про способность сайтов узнавать информацию о посетителе (и всевозможные предупреждения по этому поводу), которую невозможно узнать из IP-адреса. Это такие «личные» данные, как операционная система, используемый браузер, язык системы. Кто же так жестоко палит нас? И как можно это использовать в своих благих намерениях? Об этом и многом другом ты узнаешь, прочитав статью до конца.Для начала приведу немного теории о том, чем мы пользуемся довольно давно. HTTP (HyperText Transfer Protocol – «протокол передачи гипертекста») – клиент-серверный протокол передачи данных, который служит для получения информации с веб-сайтов. Был предложен создателем всея WWW Тимом Бернерсом-Ли. Структура его проста: тип сообщения, заголовки, тело сообщения. Существуют RFC, стандартизирующие HTTP (последняя версия – 1.1), согласно которым клиент должен посылать серверу заголовки, содержащие ту самую специфическую информацию о системе и браузере. Обычному пользователю это полезно: сайт в зависимости от клиента может выдать специфическую верстку (пример – google.com) или показать информацию на нужном языке. Однако для хакера раскрытие такой информации может быть вредно или даже опасно. Представим ситуацию: некий Иван зашел на сайт, посмотрел на него и решил взломать. Загрузил проверенные соксы, поставил красивый дефейс и через несколько часов/дней сидел в участке. Ведь несложно сопоставить данные взломщика с данными остальных посетителей и найти настоящий IP (очень редко встретишь сайт без логирования). Да, некоторые факторы не учтены, однако, вариант возможный.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'2', 'title'=>'Сокеты — введение', 'text'=>'Ещё один вид транспорта в unix системах, про который я пока не успел ничего рассказать - это сокеты. В переводе с английского, сокет - это штекер, т.е. элемент, позволяющий соединять между собой всякую фигню, например приборы. Для лучшего объяснения работы сокетов, удобно использовать популярный в интернете пример с телефоном и телефонной станцией. Где телефонная станция, словно сервер, держит соединения с сотнями или может тысячами различных телефонных аппаратов, а телефоны, эпизодически устанавливают соединение со станцией, и обмениваются своими данными. Ровно такая же идея работает и в сокетах, с той лишь разницей что сокет - это интерфейс для доступа к памяти компьтера. Сокеты подразделяются на два вида: “Локальные” или “юникс-сокеты” И “веб-сокеты” или ещё их называют “сетевые сокеты” При этом локальные сокеты видны в файловой системе как файл, но при этом все данные сохраняются в локальной памяти на уровне ядра. А сетевые сокеты биндятся на сетевой порт, и слушают его, являя собой настоящий веб-сервер. (Вы ведь уже придумали что с этим можно сделать, да?) Понятно, что и создание файла, и бинд порта может делать только один процесс, и его мы обычно называем сервером. “Сервер” обязан запускаться раньше всех и создавать свой файл или слушать свой порт, повисая в бесконечном цикле. После чего довольные клиенты должны обращаться к уже созданному файлу и записывать туда (читать оттуда) информацию, или слать невнятные сообщения на сетевой адрес с настоящим IP адресом и портом. В реализации на php между сетевыми и локальными сокетами разница заметна только в коннекте. Во всём остальном они одинаковы.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'3', 'title'=>'Сокеты - сетевое программирование', 'text'=>'Сокеты (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'4', 'title'=>'ДИАГРАММЫ ВАРИАНТОВ ИСПОЛЬЗОВАНИЯ', 'text'=>'Диаграмма вариантов использования (сценариев поведения, прецедентов) является исходным концептуальным представлением системы в процессе ее проектирования и разработки. Данная диаграмма состоит из актеров, вариантов использования и отношений между ними. При построении диаграммы могут использоваться также общие элементы нотации: примечания и механизмы расширения. Суть данной диаграммы состоит в следующем [28]: проектируемая система представляется в виде множества актеров, взаимодействующих с системой с помощью так называемых вариантов использования. При этом актером (действующим лицом, актантом, актором) называется любой объект, субъект или система, взаимодействующая с моделируемой системой извне. В свою очередь вариант использования – это спецификация сервисов (функций), которые система предоставляет актеру. Другими словами, каждый вариант использования определяет некоторый набор действий, совершаемых системой при взаимодействии с актером. При этом в модели никак не отражается то, каким образом будет реализован этот набор действий. В структурном подходе аналогом диаграммы вариантов использования являются диаграммы IDEF0 и DFD, вариантов использования – работы (IDEF0) и процессы (DFD), актеров – внешние сущности (DFD). Согласно UML актера графически можно отобразить тремя способами. Первый способ отображения в виде «проволочного человечка» является самым распространенным. Вариант использования обозначается на диаграмме эллипсом, внутри которого содержится его описание, обозначающее выполнение какой-либо операции или действия. Вариант использования, который инициализируется по запросу пользователя, представляет собой законченную последовательность действий. Это означает, что после того, как система закончит обработку запроса актера, она должна возвратиться в состояние, в котором готова к выполнению следующих запросов. Варианты использования могут включать в себя описание особенностей способов реализации сервиса и различных исключительных ситуаций, таких как корректная обработка ошибок системы. Примечания предназначены для включения в диаграмму произвольной текстовой информации, имеющей непосредственное отношение к контексту разрабатываемой системы. В качестве такой информации могут быть комментарии разработчика и ограничения. Графически примечания отображаются прямоугольником с загнутым верхним правым уголком, внутри которого содержится текст примечания. Линия, соединяющая примечание и элемент диаграммы, называется якорем (фиксацией).', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'5', 'title'=>'Инициализация в современном C++', 'text'=>'Общеизвестно, что семантика инициализации — одна из наиболее сложных частей C++. Существует множество видов инициализации, описываемых разным синтаксисом, и все они взаимодействуют сложным и вызывающим вопросы способом. C++11 принес концепцию «универсальной инициализации». К сожалению, она привнесла еще более сложные правила, и в свою очередь, их перекрыли в C++14, C++17 и снова поменяют в C++20. Под катом — видео и перевод доклада Тимура Домлера (Timur Doumler) с конференции C++ Russia. Тимур вначале подводит исторические итоги эволюции инициализации в С++, дает системный обзор текущего варианта правила инициализации, типичных проблем и сюрпризов, объясняет, как использовать все эти правила эффективно, и, наконец, рассказывает о свежих предложениях в стандарт, которые могут сделать семантику инициализации C++20 немного более удобной. Далее повествование — от его лица. Table of Contents Инициализация по умолчанию (С) Копирующая инициализация (С) Агрегатная инициализация (С) Статическая инициализация (С) Прямая инициализация (С++98) Инициализация значением (C++03) Универсальная инициализация (C++11) Улучшения в С++14 Как правильно инициализировать в C++ Назначенная инициализация (С++20) Исправления в C++20 Прямая инициализация агрегатных типов (C++20)', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'6', 'title'=>'Pagination на PHP', 'text'=>'Когда-то я писал статью про создание навигации по страницам. В этой статье я рассказывал, как получить набор данных из таблицы БД, соответствующей выбранной пользователем странице. В этой же статье мы разберём вывод Pagination на PHP. Pagination - это список самих страниц. В Интернете есть различные варианты, но все они страдают одним - огромное количество кода для создания бесконечного числа вариантов. Но Вам разве нужна бесконечность? Вам нужен только 1 вариант, который и будет стоять на сайте. В этой статье мы с Вами создадим относительно сложный pagination, но при этом кода будет совсем не много. Чтобы создать Pagination на PHP, нам необходимо иметь на входе несколько параметров: count_pages - количество страниц. active - текущая активная страница. count_show_pages - количество отображаемых страниц. Например, если будет 1000 страниц, то вывести их все весьма проблемно. Поэтому отображаться будет только заданное количество в этом параметре. url - адрес страницы, для которой и создаётся Pagination. url_page - адрес страницы с параметром page без значения на конце. Например, "/abc.php?func=create&amp;page=". Сразу скажу, что кода хоть и немного, но он достаточно сложный для новичков. Года 3 назад я потратил очень много времени, чтобы сделать нечто подобное и тогда кода получилось раза в 2 больше. А дальше можно этот Pagination через CSS украшать так, как Вы пожелаете. Можно и вёрстку изменить при желании (например, вместо угловых скобок "Предыдущая страница" и аналогичных поставить красивые картинки), главное, не трогать PHP-код. Вот такой весьма удобный Pagination реализован на этом сайте, а так же на некоторых моих других сайтах.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'7', 'title'=>'Указатели, ссылки и массивы в C и C++: точки над i', 'text'=>'В этом посте я постараюсь окончательно разобрать такие тонкие понятия в C и C++, как указатели, ссылки и массивы. В частности, я отвечу на вопрос, так являются массивы C указателями или нет. Обозначения и предположения Я буду предполагать, что читатель понимает, что, например, в C++ есть ссылки, а в C — нет, поэтому я не буду постоянно напоминать, о каком именно языке (C/C++ или именно C++) я сейчас говорю, читатель поймёт это из контекста; Также, я предполагаю, что читатель уже знает C и C++ на базовом уровне и знает, к примеру, синтаксис объявления ссылки. В этом посте я буду заниматься именно дотошным разбором мелочей; Буду обозначать типы так, как выглядело бы объявление переменной TYPE соответствующего типа. Например, тип «массив длины 2 int-ов» я буду обозначать как int TYPE[2]; Я буду предполагать, что мы в основном имеем дело с обычными типами данных, такими как int TYPE, int *TYPE и т. д., для которых операции =, &, * и другие не переопределены и обозначают обычные вещи; «Объект» всегда будет означать «всё, что не ссылка», а не «экземпляр класса»; Везде, за исключением специально оговоренных случаев, подразумеваются C89 и C++98. Указатели и ссылки Указатели. Что такое указатели, я рассказывать не буду. :) Будем считать, что вы это знаете. Напомню лишь следующие вещи (все примеры кода предполагаются находящимися внутри какой-нибудь функции, например, main): int x; int *y = &x; // От любой переменной можно взять адрес при помощи операции взятия адреса "&". Эта операция возвращает указатель int z = *y; // Указатель можно разыменовать при помощи операции разыменовывания "*". Это операция возвращает тот объект, на который указывает указатель Также напомню следующее: char — это всегда ровно один байт и во всех стандартах C и C++ sizeof (char) == 1 (но при этом стандарты не гарантируют, что в байте содержится именно 8 бит :)). Далее, если прибавить к указателю на какой-нибудь тип T число, то реальное численное значение этого указателя увеличится на это число, умноженное на sizeof (T). Т. е. если p имеет тип T *TYPE, то p + 3 эквивалентно (T *)((char *)p + 3 * sizeof (T)). Аналогичные соображения относятся и к вычитанию. Ссылки. Теперь по поводу ссылок. Ссылки — это то же самое, что и указатели, но с другим синтаксисом и некоторыми другими важными отличиями, о которых речь пойдёт дальше. Следующий код ничем не отличается от предыдущего, за исключением того, что в нём фигурируют ссылки вместо указателей: int x; int &y = x; int z = y; Если слева от знака присваивания стоит ссылка, то нет никакого способа понять, хотим мы присвоить самой ссылке или объекту, на который она ссылается. Поэтому такое присваивание всегда присваивает объекту, а не ссылке. Но это не относится к инициализации ссылки: инициализируется, разумеется, сама ссылка. Поэтому после инициализации ссылки нет никакого способа изменить её саму, т. е. ссылка всегда постоянна (но не её объект). Lvalue. Те выражения, которым можно присваивать, называются lvalue в C, C++ и многих других языках (это сокращение от «left value», т. е. слева от знака равенства). Остальные выражения называются rvalue. Имена переменных очевидным образом являются lvalue, но не только они. Выражения a[i + 2], some_struct.some_field, *ptr, *(ptr + 3) — тоже lvalue.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'8', 'title'=>'Нейросети для чайников. Начало', 'text'=>'Так получилось, что в университете тема нейросетей успешно прошла мимо моей специальности, несмотря на огромный интерес с моей стороны. Попытки самообразования несколько раз разбивались невежественным челом о несокрушимые стены цитадели науки в облике непонятных «с наскока» терминов и путанных объяснений сухим языком вузовских учебников. В данной статье (цикле статей?) я попытаюсь осветить тему нейросетей с точки зрения человека непосвященного, простым языком, на простых примерах, раскладывая все по полочкам, а не «массив нейронов образует перцептрон, работающий по известной, зарекомендовавшей себя схеме». Заинтересовавшихся прошу под кат. Цели Для чего же нужны нейросети? Нейросеть – это обучаемая система. Она действует не только в соответствии с заданным алгоритмом и формулами, но и на основании прошлого опыта. Этакий ребенок, который с каждым разом складывает пазл, делая все меньше ошибок. И, как принято писать у модных авторов – нейросеть состоит из нейронов. Тут нужно сделать остановку и разобраться. Договоримся, что нейрон – это просто некая воображаемая чёрная коробка, у которой кучка входных отверстий и одно выходное. Причем как входящая, так и исходящая информация может быть аналоговой (чаще всего так и будет). Как выходной сигнал формируется из кучи входных – определяет внутренний алгоритм нейрона. Для примера напишем небольшую программу, которая будет распознавать простые изображения, скажем, буквы русского языка на растровых изображениях. Условимся, что в исходном состоянии наша система будет иметь «пустую» память, т.е. этакий новорожденный мозг, готовый к бою. Для того чтобы заставить его корректно работать, нам нужно будет потратить время на обучение. Уворачиваясь от летящих в меня помидоров, скажу, что писать будем на Delphi (на момент написания статьи была под рукой). Если возникнет необходимость – помогу перевести пример на другие языки. Также прошу легкомысленно отнестись к качеству кода – программа писалась за час, просто чтобы разобраться с темой, для серьезных задач такой код вряд ли применим. Итак, исходя из поставленной задачи — сколько вариантов выхода может быть? Правильно, столько, сколько букв мы будем уметь определять. В алфавите их пока только 33, на том и остановимся.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'9', 'title'=>'Основа www: протокол HTTP', 'text'=>'HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — символьно-ориентированный клиент-серверный протокол прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier – уникальный идентификатор ресурса) в запросе клиента. Основными ресурсами являются хранящиеся на сервере файлы, но ими могут быть и другие логические (напр. каталог на сервере) или абстрактные объекты (напр. ISBN). Протокол HTTP позволяет указать способ представления (кодирования) одного и того же ресурса по различным параметрам: mime-типу, языку и т. д. Благодаря этой возможности клиент и веб-сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым. Структура протокола Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей (рис. 1), которые передаются в следующем порядке: Стартовая строка (англ. Starting line) — определяет тип сообщения; Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения; Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.', 'created_at'=>date('Y-m-d H:i:s')]);
        Article::create(['id'=>'10', 'title'=>'Неуправляемый вызов Dll', 'text'=>'Lorem ipsum dolor sit amet, consectetur adipisicing elit. A, accusamus ad architecto aut consectetur consequatur debitis delectus deserunt, facere id laborum libero magnam maxime minima modi molestias nostrum pariatur quaerat quidem, voluptates! Dignissimos et, eum fugiat nesciunt sunt veritatis voluptatem voluptates. Alias atque, autem dicta dolor doloremque dolores est et excepturi expedita fugit iste magni minus nemo, numquam officiis placeat praesentium quam quasi quidem quod rem repellat repellendus temporibus tenetur velit voluptate voluptates? Ab adipisci aliquam asperiores culpa cum deserunt dolore eos eum fuga id, inventore laborum laudantium molestiae necessitatibus nemo nihil officia, optio perferendis porro quia quis quos reprehenderit sequi sit, temporibus tenetur veritatis voluptas! Adipisci, assumenda corporis cumque distinctio ea eligendi enim eveniet expedita facere facilis illum impedit inventore ipsa laudantium mollitia natus officiis perferendis, provident quia rem repellat repudiandae sed sequi sint soluta ullam vero? Consectetur eaque mollitia nulla. Dolore dolores illo, libero omnis quasi quod sed unde voluptatibus. Commodi culpa distinctio doloremque eius, excepturi expedita facilis nesciunt, obcaecati odio quae quas quibusdam quidem rerum sapiente sit vel voluptas voluptatibus. Aliquid commodi consectetur culpa, delectus deserunt dicta distinctio dolor dolorem dolorum et ex facere facilis harum ipsa, itaque iure laborum molestias nam nihil nobis nostrum numquam odio optio pariatur perspiciatis placeat provident quas quidem quisquam, quod rem reprehenderit sapiente sed sit totam veniam veritatis! A at, dicta doloribus eius eos eveniet facere fugit illo laudantium mollitia, nemo nostrum nulla omnis provident quod rem repellat rerum sed similique sit suscipit temporibus voluptas voluptate. Accusantium alias aperiam, assumenda cumque doloribus dolorum esse facilis, hic ipsa ipsum iure maiores, minima nam odio omnis optio provident quod veniam. Eligendi mollitia officiis placeat quibusdam sed sunt? Ab accusamus atque autem deserunt dignissimos dolorem dolorum ea eligendi eos in nesciunt nostrum, odit placeat repudiandae velit. Cum, id natus? At consectetur corporis dolores earum esse est, eum expedita illum laboriosam molestiae, nisi officia perspiciatis, saepe sed soluta tempore temporibus tenetur velit veniam voluptate. Ab ad aliquam architecto blanditiis consectetur corporis cum cupiditate delectus deserunt dolores eaque error eveniet excepturi fugiat fugit hic illum incidunt ipsam magnam magni maxime minus molestias mollitia nemo nesciunt nisi optio praesentium provident quas quasi quos similique ullam vel, vero voluptate voluptatem voluptatum! Accusantium aperiam, consequuntur culpa dolorum eaque earum molestiae necessitatibus non quaerat quidem, similique tempora veniam vitae. Accusantium atque autem ducimus eius eum eveniet ex, excepturi explicabo ipsum libero obcaecati quasi qui quia quidem tempora temporibus voluptate voluptates?', 'created_at'=>date('Y-m-d H:i:s')]);
//        DB::insert('
//            INSERT INTO `articles`
//            (`id`, `title`, `text`, created_at, updated_at) VALUES
//            (1, "Такие разные заголовки! Изучаем HTTP-взаимодействие", "Большинство из нас многократно слышали про способность сайтов узнавать информацию о посетителе (и всевозможные предупреждения по этому поводу), которую невозможно узнать из IP-адреса. Это такие «личные» данные, как операционная система, используемый браузер, язык системы. Кто же так жестоко палит нас? И как можно это использовать в своих благих намерениях? Об этом и многом другом ты узнаешь, прочитав статью до конца.Для начала приведу немного теории о том, чем мы пользуемся довольно давно. HTTP (HyperText Transfer Protocol – «протокол передачи гипертекста») – клиент-серверный протокол передачи данных, который служит для получения информации с веб-сайтов. Был предложен создателем всея WWW Тимом Бернерсом-Ли. Структура его проста: тип сообщения, заголовки, тело сообщения. Существуют RFC, стандартизирующие HTTP (последняя версия – 1.1), согласно которым клиент должен посылать серверу заголовки, содержащие ту самую специфическую информацию о системе и браузере. Обычному пользователю это полезно: сайт в зависимости от клиента может выдать специфическую верстку (пример – google.com) или показать информацию на нужном языке. Однако для хакера раскрытие такой информации может быть вредно или даже опасно. Представим ситуацию: некий Иван зашел на сайт, посмотрел на него и решил взломать. Загрузил проверенные соксы, поставил красивый дефейс и через несколько часов/дней сидел в участке. Ведь несложно сопоставить данные взломщика с данными остальных посетителей и найти настоящий IP (очень редко встретишь сайт без логирования). Да, некоторые факторы не учтены, однако, вариант возможный.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (2, "Сокеты — введение", "Ещё один вид транспорта в unix системах, про который я пока не успел ничего рассказать - это сокеты. В переводе с английского, сокет - это штекер, т.е. элемент, позволяющий соединять между собой всякую фигню, например приборы. Для лучшего объяснения работы сокетов, удобно использовать популярный в интернете пример с телефоном и телефонной станцией. Где телефонная станция, словно сервер, держит соединения с сотнями или может тысячами различных телефонных аппаратов, а телефоны, эпизодически устанавливают соединение со станцией, и обмениваются своими данными. Ровно такая же идея работает и в сокетах, с той лишь разницей что сокет - это интерфейс для доступа к памяти компьтера. Сокеты подразделяются на два вида: “Локальные” или “юникс-сокеты” И “веб-сокеты” или ещё их называют “сетевые сокеты” При этом локальные сокеты видны в файловой системе как файл, но при этом все данные сохраняются в локальной памяти на уровне ядра. А сетевые сокеты биндятся на сетевой порт, и слушают его, являя собой настоящий веб-сервер. (Вы ведь уже придумали что с этим можно сделать, да?) Понятно, что и создание файла, и бинд порта может делать только один процесс, и его мы обычно называем сервером. “Сервер” обязан запускаться раньше всех и создавать свой файл или слушать свой порт, повисая в бесконечном цикле. После чего довольные клиенты должны обращаться к уже созданному файлу и записывать туда (читать оттуда) информацию, или слать невнятные сообщения на сетевой адрес с настоящим IP адресом и портом. В реализации на php между сетевыми и локальными сокетами разница заметна только в коннекте. Во всём остальном они одинаковы.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (3, "Сокеты - сетевое программирование", "Сокеты (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (4, "ДИАГРАММЫ ВАРИАНТОВ ИСПОЛЬЗОВАНИЯ", "Диаграмма вариантов использования (сценариев поведения, прецедентов) является исходным концептуальным представлением системы в процессе ее проектирования и разработки. Данная диаграмма состоит из актеров, вариантов использования и отношений между ними. При построении диаграммы могут использоваться также общие элементы нотации: примечания и механизмы расширения. Суть данной диаграммы состоит в следующем [28]: проектируемая система представляется в виде множества актеров, взаимодействующих с системой с помощью так называемых вариантов использования. При этом актером (действующим лицом, актантом, актором) называется любой объект, субъект или система, взаимодействующая с моделируемой системой извне. В свою очередь вариант использования – это спецификация сервисов (функций), которые система предоставляет актеру. Другими словами, каждый вариант использования определяет некоторый набор действий, совершаемых системой при взаимодействии с актером. При этом в модели никак не отражается то, каким образом будет реализован этот набор действий. В структурном подходе аналогом диаграммы вариантов использования являются диаграммы IDEF0 и DFD, вариантов использования – работы (IDEF0) и процессы (DFD), актеров – внешние сущности (DFD). Согласно UML актера графически можно отобразить тремя способами. Первый способ отображения в виде «проволочного человечка» является самым распространенным. Вариант использования обозначается на диаграмме эллипсом, внутри которого содержится его описание, обозначающее выполнение какой-либо операции или действия. Вариант использования, который инициализируется по запросу пользователя, представляет собой законченную последовательность действий. Это означает, что после того, как система закончит обработку запроса актера, она должна возвратиться в состояние, в котором готова к выполнению следующих запросов. Варианты использования могут включать в себя описание особенностей способов реализации сервиса и различных исключительных ситуаций, таких как корректная обработка ошибок системы. Примечания предназначены для включения в диаграмму произвольной текстовой информации, имеющей непосредственное отношение к контексту разрабатываемой системы. В качестве такой информации могут быть комментарии разработчика и ограничения. Графически примечания отображаются прямоугольником с загнутым верхним правым уголком, внутри которого содержится текст примечания. Линия, соединяющая примечание и элемент диаграммы, называется якорем (фиксацией).", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (5, "Инициализация в современном C++", "Общеизвестно, что семантика инициализации — одна из наиболее сложных частей C++. Существует множество видов инициализации, описываемых разным синтаксисом, и все они взаимодействуют сложным и вызывающим вопросы способом. C++11 принес концепцию «универсальной инициализации». К сожалению, она привнесла еще более сложные правила, и в свою очередь, их перекрыли в C++14, C++17 и снова поменяют в C++20. Под катом — видео и перевод доклада Тимура Домлера (Timur Doumler) с конференции C++ Russia. Тимур вначале подводит исторические итоги эволюции инициализации в С++, дает системный обзор текущего варианта правила инициализации, типичных проблем и сюрпризов, объясняет, как использовать все эти правила эффективно, и, наконец, рассказывает о свежих предложениях в стандарт, которые могут сделать семантику инициализации C++20 немного более удобной. Далее повествование — от его лица. Table of Contents Инициализация по умолчанию (С) Копирующая инициализация (С) Агрегатная инициализация (С) Статическая инициализация (С) Прямая инициализация (С++98) Инициализация значением (C++03) Универсальная инициализация (C++11) Улучшения в С++14 Как правильно инициализировать в C++ Назначенная инициализация (С++20) Исправления в C++20 Прямая инициализация агрегатных типов (C++20)", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (6, "Pagination на PHP", "Когда-то я писал статью про создание навигации по страницам. В этой статье я рассказывал, как получить набор данных из таблицы БД, соответствующей выбранной пользователем странице. В этой же статье мы разберём вывод Pagination на PHP. Pagination - это список самих страниц. В Интернете есть различные варианты, но все они страдают одним - огромное количество кода для создания бесконечного числа вариантов. Но Вам разве нужна бесконечность? Вам нужен только 1 вариант, который и будет стоять на сайте. В этой статье мы с Вами создадим относительно сложный pagination, но при этом кода будет совсем не много. Чтобы создать Pagination на PHP, нам необходимо иметь на входе несколько параметров: count_pages - количество страниц. active - текущая активная страница. count_show_pages - количество отображаемых страниц. Например, если будет 1000 страниц, то вывести их все весьма проблемно. Поэтому отображаться будет только заданное количество в этом параметре. url - адрес страницы, для которой и создаётся Pagination. url_page - адрес страницы с параметром page без значения на конце. Например, \"/abc.php?func=create&amp;page=\". Сразу скажу, что кода хоть и немного, но он достаточно сложный для новичков. Года 3 назад я потратил очень много времени, чтобы сделать нечто подобное и тогда кода получилось раза в 2 больше. А дальше можно этот Pagination через CSS украшать так, как Вы пожелаете. Можно и вёрстку изменить при желании (например, вместо угловых скобок \"Предыдущая страница\" и аналогичных поставить красивые картинки), главное, не трогать PHP-код. Вот такой весьма удобный Pagination реализован на этом сайте, а так же на некоторых моих других сайтах.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (7, "Указатели, ссылки и массивы в C и C++: точки над i", \'В этом посте я постараюсь окончательно разобрать такие тонкие понятия в C и C++, как указатели, ссылки и массивы. В частности, я отвечу на вопрос, так являются массивы C указателями или нет. Обозначения и предположения Я буду предполагать, что читатель понимает, что, например, в C++ есть ссылки, а в C — нет, поэтому я не буду постоянно напоминать, о каком именно языке (C/C++ или именно C++) я сейчас говорю, читатель поймёт это из контекста; Также, я предполагаю, что читатель уже знает C и C++ на базовом уровне и знает, к примеру, синтаксис объявления ссылки. В этом посте я буду заниматься именно дотошным разбором мелочей; Буду обозначать типы так, как выглядело бы объявление переменной TYPE соответствующего типа. Например, тип «массив длины 2 int-ов» я буду обозначать как int TYPE[2]; Я буду предполагать, что мы в основном имеем дело с обычными типами данных, такими как int TYPE, int *TYPE и т. д., для которых операции =, &, * и другие не переопределены и обозначают обычные вещи; «Объект» всегда будет означать «всё, что не ссылка», а не «экземпляр класса»; Везде, за исключением специально оговоренных случаев, подразумеваются C89 и C++98. Указатели и ссылки Указатели. Что такое указатели, я рассказывать не буду. :) Будем считать, что вы это знаете. Напомню лишь следующие вещи (все примеры кода предполагаются находящимися внутри какой-нибудь функции, например, main): int x; int *y = &x; // От любой переменной можно взять адрес при помощи операции взятия адреса "&". Эта операция возвращает указатель int z = *y; // Указатель можно разыменовать при помощи операции разыменовывания "*". Это операция возвращает тот объект, на который указывает указатель Также напомню следующее: char — это всегда ровно один байт и во всех стандартах C и C++ sizeof (char) == 1 (но при этом стандарты не гарантируют, что в байте содержится именно 8 бит :)). Далее, если прибавить к указателю на какой-нибудь тип T число, то реальное численное значение этого указателя увеличится на это число, умноженное на sizeof (T). Т. е. если p имеет тип T *TYPE, то p + 3 эквивалентно (T *)((char *)p + 3 * sizeof (T)). Аналогичные соображения относятся и к вычитанию. Ссылки. Теперь по поводу ссылок. Ссылки — это то же самое, что и указатели, но с другим синтаксисом и некоторыми другими важными отличиями, о которых речь пойдёт дальше. Следующий код ничем не отличается от предыдущего, за исключением того, что в нём фигурируют ссылки вместо указателей: int x; int &y = x; int z = y; Если слева от знака присваивания стоит ссылка, то нет никакого способа понять, хотим мы присвоить самой ссылке или объекту, на который она ссылается. Поэтому такое присваивание всегда присваивает объекту, а не ссылке. Но это не относится к инициализации ссылки: инициализируется, разумеется, сама ссылка. Поэтому после инициализации ссылки нет никакого способа изменить её саму, т. е. ссылка всегда постоянна (но не её объект). Lvalue. Те выражения, которым можно присваивать, называются lvalue в C, C++ и многих других языках (это сокращение от «left value», т. е. слева от знака равенства). Остальные выражения называются rvalue. Имена переменных очевидным образом являются lvalue, но не только они. Выражения a[i + 2], some_struct.some_field, *ptr, *(ptr + 3) — тоже lvalue.\', CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (8, "Нейросети для чайников. Начало", "Так получилось, что в университете тема нейросетей успешно прошла мимо моей специальности, несмотря на огромный интерес с моей стороны. Попытки самообразования несколько раз разбивались невежественным челом о несокрушимые стены цитадели науки в облике непонятных «с наскока» терминов и путанных объяснений сухим языком вузовских учебников. В данной статье (цикле статей?) я попытаюсь осветить тему нейросетей с точки зрения человека непосвященного, простым языком, на простых примерах, раскладывая все по полочкам, а не «массив нейронов образует перцептрон, работающий по известной, зарекомендовавшей себя схеме». Заинтересовавшихся прошу под кат. Цели Для чего же нужны нейросети? Нейросеть – это обучаемая система. Она действует не только в соответствии с заданным алгоритмом и формулами, но и на основании прошлого опыта. Этакий ребенок, который с каждым разом складывает пазл, делая все меньше ошибок. И, как принято писать у модных авторов – нейросеть состоит из нейронов. Тут нужно сделать остановку и разобраться. Договоримся, что нейрон – это просто некая воображаемая чёрная коробка, у которой кучка входных отверстий и одно выходное. Причем как входящая, так и исходящая информация может быть аналоговой (чаще всего так и будет). Как выходной сигнал формируется из кучи входных – определяет внутренний алгоритм нейрона. Для примера напишем небольшую программу, которая будет распознавать простые изображения, скажем, буквы русского языка на растровых изображениях. Условимся, что в исходном состоянии наша система будет иметь «пустую» память, т.е. этакий новорожденный мозг, готовый к бою. Для того чтобы заставить его корректно работать, нам нужно будет потратить время на обучение. Уворачиваясь от летящих в меня помидоров, скажу, что писать будем на Delphi (на момент написания статьи была под рукой). Если возникнет необходимость – помогу перевести пример на другие языки. Также прошу легкомысленно отнестись к качеству кода – программа писалась за час, просто чтобы разобраться с темой, для серьезных задач такой код вряд ли применим. Итак, исходя из поставленной задачи — сколько вариантов выхода может быть? Правильно, столько, сколько букв мы будем уметь определять. В алфавите их пока только 33, на том и остановимся.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (9, "Основа www: протокол HTTP", "HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — символьно-ориентированный клиент-серверный протокол прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier – уникальный идентификатор ресурса) в запросе клиента. Основными ресурсами являются хранящиеся на сервере файлы, но ими могут быть и другие логические (напр. каталог на сервере) или абстрактные объекты (напр. ISBN). Протокол HTTP позволяет указать способ представления (кодирования) одного и того же ресурса по различным параметрам: mime-типу, языку и т. д. Благодаря этой возможности клиент и веб-сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым. Структура протокола Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей (рис. 1), которые передаются в следующем порядке: Стартовая строка (англ. Starting line) — определяет тип сообщения; Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения; Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP()),
//            (10, "Unmanaged C++ Dll Call From Managed C# Application", "Lorem ipsum dolor sit amet, consectetur adipisicing elit. A, accusamus ad architecto aut consectetur consequatur debitis delectus deserunt, facere id laborum libero magnam maxime minima modi molestias nostrum pariatur quaerat quidem, voluptates! Dignissimos et, eum fugiat nesciunt sunt veritatis voluptatem voluptates. Alias atque, autem dicta dolor doloremque dolores est et excepturi expedita fugit iste magni minus nemo, numquam officiis placeat praesentium quam quasi quidem quod rem repellat repellendus temporibus tenetur velit voluptate voluptates? Ab adipisci aliquam asperiores culpa cum deserunt dolore eos eum fuga id, inventore laborum laudantium molestiae necessitatibus nemo nihil officia, optio perferendis porro quia quis quos reprehenderit sequi sit, temporibus tenetur veritatis voluptas! Adipisci, assumenda corporis cumque distinctio ea eligendi enim eveniet expedita facere facilis illum impedit inventore ipsa laudantium mollitia natus officiis perferendis, provident quia rem repellat repudiandae sed sequi sint soluta ullam vero? Consectetur eaque mollitia nulla. Dolore dolores illo, libero omnis quasi quod sed unde voluptatibus. Commodi culpa distinctio doloremque eius, excepturi expedita facilis nesciunt, obcaecati odio quae quas quibusdam quidem rerum sapiente sit vel voluptas voluptatibus. Aliquid commodi consectetur culpa, delectus deserunt dicta distinctio dolor dolorem dolorum et ex facere facilis harum ipsa, itaque iure laborum molestias nam nihil nobis nostrum numquam odio optio pariatur perspiciatis placeat provident quas quidem quisquam, quod rem reprehenderit sapiente sed sit totam veniam veritatis! A at, dicta doloribus eius eos eveniet facere fugit illo laudantium mollitia, nemo nostrum nulla omnis provident quod rem repellat rerum sed similique sit suscipit temporibus voluptas voluptate. Accusantium alias aperiam, assumenda cumque doloribus dolorum esse facilis, hic ipsa ipsum iure maiores, minima nam odio omnis optio provident quod veniam. Eligendi mollitia officiis placeat quibusdam sed sunt? Ab accusamus atque autem deserunt dignissimos dolorem dolorum ea eligendi eos in nesciunt nostrum, odit placeat repudiandae velit. Cum, id natus? At consectetur corporis dolores earum esse est, eum expedita illum laboriosam molestiae, nisi officia perspiciatis, saepe sed soluta tempore temporibus tenetur velit veniam voluptate. Ab ad aliquam architecto blanditiis consectetur corporis cum cupiditate delectus deserunt dolores eaque error eveniet excepturi fugiat fugit hic illum incidunt ipsam magnam magni maxime minus molestias mollitia nemo nesciunt nisi optio praesentium provident quas quasi quos similique ullam vel, vero voluptate voluptatem voluptatum! Accusantium aperiam, consequuntur culpa dolorum eaque earum molestiae necessitatibus non quaerat quidem, similique tempora veniam vitae. Accusantium atque autem ducimus eius eum eveniet ex, excepturi explicabo ipsum libero obcaecati quasi qui quia quidem tempora temporibus voluptate voluptates?", CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP());
//            ');

    }
}
